<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VujAQ3bHzgNYiC3C61DJwUmXP7xW6bB8tT92xAKhDyu5vXReakaHVSrqJfurggZdCJVuAf3B7AujNBvkJAcz974uH" type="text/javascript"></script></head><body><div id="clerk"></div><script>let viewer = nextjournal.clerk.sci_viewer
let doc = "{:nextjournal/value [{:nextjournal/value \"# [Day 18](https://adventofcode.com/2021/day/18)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(ns advent-of-code-2021.day18\\n  (:require [clojure.edn :as edn]\\n            [clojure.java.io :as io]\\n            [clojure.set :as sets]\\n            [clojure.string :as string]\\n            [clojure.zip :as zip]\\n            [nextjournal.clerk :as clerk]\\n            [nextjournal.clerk.viewer :as v]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"ojure.core$nil_QMARK_ 0x2f48adcc \\\\\\\"clojure.core$nil_QMARK_@2f48adcc\\\\\\\"\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Since Snailfish numbers are just nested vectors of integers I used Clojure\\n Zippers to navigate around them. It turns out finding the next \\\"left\\\" and\\n \\\"right\\\" integers is super easy with zippers since the `clojure.zip/next` and\\n `clojure.zip/prev` can just be applied repeatedly and do that correct thing\\n when needing to move up/down the nested structure.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Since splitting is easier than exploding I started there. To find the next\\n splitable location start at the root and keep traversing with `next` until\\n an integer over 10 is found.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" I found some good info on how to use zippers from: [https://grishaev.me/en/clojure-zippers/](https://grishaev.me/en/clojure-zippers/) \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn find-first-splitable\\n  [z]\\n  (let [n (zip/node z)]\\n    (cond (zip/end? z) nil\\n          (and (int? n) (<= 10 n)) z\\n          :else (recur (zip/next z)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$find_first_splitable 0x49511122 \\\\\\\"advent_of_code_2021.day18$find_first_splitable@49511122\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn n->pair\\n  [n]\\n  [(long (Math/floor (/ n 2.0)))\\n   (long (Math/ceil (/ n 2.0)))])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$n__GT_pair 0xccc47f6 \\\\\\\"advent_of_code_2021.day18$n__GT_pair@ccc47f6\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn split\\n  [z]\\n  (zip/edit z n->pair))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$split 0x7196f094 \\\\\\\"advent_of_code_2021.day18$split@7196f094\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn split-first\\n  [fish-num]\\n  (if-let [loc (find-first-splitable (zip/vector-zip fish-num))]\\n    (zip/root (split loc))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$split_first 0x3942fbb9 \\\\\\\"advent_of_code_2021.day18$split_first@3942fbb9\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The length of the path to a location in a zipper is the same as it's depth.\\n This means that again just but calling next repeatedly it's possible to go \\n through the zipper and stop when the conditions are met for an explodable\\n location \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn find-first-explodable\\n  [z]\\n  (cond (zip/end? z)\\n        nil\\n        (and (= 4 (count (zip/path z))) (vector? (zip/node z)))\\n        z\\n        :else\\n        (recur (zip/next z))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$find_first_explodable 0x785b35b2 \\\\\\\"advent_of_code_2021.day18$find_first_explodable@785b35b2\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Starting from an explodable location find the next and previous integer\\n locations to they can be updated during the explode operation.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn find-next-int\\n  [z]\\n  (cond (zip/end? z) nil\\n        (int? (zip/node z)) z\\n        :else (recur (zip/next z))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$find_next_int 0x16c63eb8 \\\\\\\"advent_of_code_2021.day18$find_next_int@16c63eb8\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn find-prev-int\\n  [z]\\n  (cond (nil? (zip/path z)) nil\\n        (int? (zip/node z)) z\\n        :else (recur (zip/prev z))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$find_prev_int 0x50927ea4 \\\\\\\"advent_of_code_2021.day18$find_prev_int@50927ea4\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" This was the trickiest part of the implementation and I'm not very happy with\\n it but it does work. I'm not sure how to save or mark a location in a zipper,\\n go off and do some navigating or editing and return to it. Because of this\\n This implementation goes back up to root and back down the explodable location\\n several times.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn explode\\n  [fish-num]\\n  (if-let [exz (find-first-explodable (zip/vector-zip fish-num))]\\n    (let [[L R] (zip/node exz)\\n          left (find-prev-int exz)\\n          exz (if (nil? left)\\n                exz\\n                (-> (zip/edit left + L)\\n                    (zip/root)\\n                    (zip/vector-zip)\\n                    (find-first-explodable)))\\n          ; have to move past the numbers in the vector at the explodable location  \\n          right (find-next-int (-> exz zip/next zip/next zip/next))\\n          exz (if (nil? right)\\n                exz\\n                (-> (zip/edit right + R)\\n                    (zip/root)\\n                    (zip/vector-zip)\\n                    (find-first-explodable)))\\n          with-zero (zip/replace exz 0)]\\n      (zip/root with-zero))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$explode 0x7ea3d83c \\\\\\\"advent_of_code_2021.day18$explode@7ea3d83c\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" To ensure the right order of operations in the reduction the `explode` and\\n `split-first` functions return nil if they didn't make any changes and the\\n new snailfish number if they did. They also only operate on the first possible\\n location.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn reduce-step\\n  [fish-num]\\n  (if-let [exploded (explode fish-num)]\\n    exploded\\n    (if-let [splitted (split-first fish-num)]\\n      splitted\\n      fish-num)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$reduce_step 0x5ff494ff \\\\\\\"advent_of_code_2021.day18$reduce_step@5ff494ff\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" To add two snailfish numbers just put them together in a vector and then keep\\n reducing until no changes are made.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn add-fish-nums\\n  [fn0 fn1]\\n  (loop [last-fish-num nil fish-num [fn0 fn1]]\\n    (if (= last-fish-num fish-num)\\n      fish-num\\n      (recur fish-num (reduce-step fish-num)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$add_fish_nums 0x78e05247 \\\\\\\"advent_of_code_2021.day18$add_fish_nums@78e05247\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Just simple recursion here no need for zippers. \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn mag\\n  [fish-num]\\n  (if (vector? fish-num)\\n    (+ (* 3 (mag (first fish-num)))\\n       (* 2 (mag (second fish-num))))\\n    fish-num))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$mag 0x3b4464a1 \\\\\\\"advent_of_code_2021.day18$mag@3b4464a1\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input\\n  \\\"[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]\\n[[[5,[2,8]],4],[5,[[9,9],0]]]\\n[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]\\n[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]\\n[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]\\n[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]\\n[[[[5,4],[7,7]],8],[[8,3],8]]\\n[[9,3],[[9,9],[6,[4,9]]]]\\n[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]\\n[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]\\\\n[[[5,[2,8]],4],[5,[[9,9],0]]]\\\\n[6,[[[6,2],[5,6]],[[\\\" {:nextjournal/value {:path [], :count 359, :offset 100, :remaining 259}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def real-input (slurp (io/resource \\\"day18.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"[[[0,[6,6]],[[7,2],[6,2]]],[[[9,4],[5,8]],6]]\\\\n[[[4,9],6],[[[0,1],[8,5]],[3,[7,6]]]]\\\\n[[1,7],[[[1,3],2\\\" {:nextjournal/value {:path [], :count 3352, :offset 100, :remaining 3252}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" It turns out that each line is valid EDN/Clojure.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn read-input\\n  [input]\\n  (map #(edn/read-string %)\\n       (string/split-lines input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$read_input 0x5bc629cd \\\\\\\"advent_of_code_2021.day18$read_input@5bc629cd\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Part 1\\n Just reduce using the addition function already figured out.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn solve-part1\\n  [input]\\n  (mag (reduce add-fish-nums input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$solve_part1 0x206e1d26 \\\\\\\"advent_of_code_2021.day18$solve_part1@206e1d26\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4140, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4116, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Part 2\\n Brute force, cuz it's fast enough. I suspect it would be much faster if the\\n explode step didn't have the traverse from root more than once.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn solve-part2\\n  [input]\\n  (reduce (fn [max-mag [n0 n1]]\\n            (max max-mag (mag (add-fish-nums n0 n1))))\\n          -1\\n          (for [n0 input n1 input :when (not= n0 n1)]\\n            [n0 n1])))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day18$solve_part2 0x5a661106 \\\\\\\"advent_of_code_2021.day18$solve_part2@5a661106\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 3993, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4638, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :advent-of-code-2021.day18}}"
viewer.reset_doc(viewer.read_string(doc))
viewer.mount(document.getElementById('clerk'))
</script></body></html>