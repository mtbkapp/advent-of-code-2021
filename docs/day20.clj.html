<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VujAQ3bHzgNYiC3C61DJwUmXP7xW6bB8tT92xAKhDyu5vXReakaHVSrqJfurggZdCJVuAf3B7AujNBvkJAcz974uH" type="text/javascript"></script></head><body><div id="clerk"></div><script>let viewer = nextjournal.clerk.sci_viewer
let doc = "{:nextjournal/value [{:nextjournal/value \"# [Day 20](https://adventofcode.com/2021/day/20)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(ns advent-of-code-2021.day20\\n  (:require [clojure.java.io :as io]\\n            [clojure.set :as sets]\\n            [clojure.string :as string]\\n            [nextjournal.clerk :as clerk]\\n            [nextjournal.clerk.viewer :as v]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"ojure.core$nil_QMARK_ 0x2670435 \\\\\\\"clojure.core$nil_QMARK_@2670435\\\\\\\"\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def real-input (slurp (io/resource \\\"day20.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"###.#....#.....##....#..#####.###..#...#.####....#..##.#.#...#..###.#####..####.#.#######.#.##..#.#.\\\" {:nextjournal/value {:path [], :count 10614, :offset 100, :remaining 10514}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x3704122f \\\\\\\"clojure.core$string_QMARK___5427@3704122f\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input\\n  \\\"..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#\\n\\n#..#.\\n#....\\n##..#\\n..#..\\n..###\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#\\\" {:nextjournal/value {:path [], :count 543, :offset 100, :remaining 443}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x3704122f \\\\\\\"clojure.core$string_QMARK___5427@3704122f\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Read the input into a few sets. First the algorithm is read into a set where\\n each element represents the offset of a `\\\\#` character. The initial image\\n is read into another set where each element are the coordinates of a lit\\n pixel. Because the image is actually infinitely there needs to be a way to \\n record if those pixels are lit or not. The pixels that are not within the\\n the image are only ever all lit or not all lit so the state is represented \\n in the key `:enhance`. The bounds of the image are also represented. \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn read-input\\n  [input]\\n  (let [split (string/split input #\\\"\\\\n\\\\n\\\")\\n        alg (into #{}\\n                  (comp (map-indexed\\n                          (fn [i x]\\n                            [i (= \\\\# x)]))\\n                        (filter (comp true? second))\\n                        (map first))\\n                  (first split))\\n        img (into #{}\\n                  (comp (map-indexed\\n                          (fn [y row]\\n                            (map-indexed (fn [x col]\\n                                           [[x y] (= \\\\# col)])\\n                                         row)))\\n                        (mapcat identity)\\n                        (filter (comp true? second))\\n                        (map first))\\n                  (string/split-lines (second split)))\\n        xs (map first img)\\n        ys (map second img)]\\n    {:alg alg\\n     :img img\\n     :expanse false\\n     :min-x (reduce min xs)\\n     :max-x (reduce max xs)\\n     :min-y (reduce min ys)\\n     :max-y (reduce max ys)}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$read_input 0x30c19e2a \\\\\\\"advent_of_code_2021.day20$read_input@30c19e2a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" I've split the infinite image into two parts the image or interesting pixels\\n and the rest which I've called the \\\"expanse\\\". Something like what is below. \\n `E` and `n` denotes and expanse pixel and `i` is an image pixel. All the\\n pixels labeled `n` and `i` are considered in each Enhance! step. Each step\\n ends by expanding the `n` pixel ring \\\"out\\\" by one pixel and turning each\\n previously `n` pixel into an `i` pixel.\\n\\n <pre>\\n EEEEEEE\\n EnnnnnE\\n EniiinE\\n EniiinE\\n EniiinE\\n EnnnnnE\\n EEEEEEE\\n </pre>\\n \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \" Turns the image back into the ascii art as they appear in the puzzle and\\n puzzle input. \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn render-stdout\\n  [{:keys [img min-x max-x min-y max-y]}]\\n  (doseq [y (range min-y (inc max-y))]\\n    (doseq [x (range min-x (inc max-x))]\\n      (print (if (contains? img [x y]) \\\\# \\\\.)))\\n    (println)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$render_stdout 0x17ac945a \\\\\\\"advent_of_code_2021.day20$render_stdout@17ac945a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Returns true if the point [x y] is in the infinite expanse (not in the image) \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn expanse?\\n  [{:keys [min-x max-x min-y max-y]} [x y]]\\n  (or (< x min-x)\\n      (< max-x x)\\n      (< y min-y)\\n      (< max-y y)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$expanse_QMARK_ 0x14053e4c \\\\\\\"advent_of_code_2021.day20$expanse_QMARK_@14053e4c\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Given a sequence of booleans returns a binary number if each boolean represents\\n a bit and the sequence of bits is turned into a long int.\\n `(true false true) => 0b101 => 5` \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn bool-seq->long\\n  [bs]\\n  (Long/valueOf (apply str (map #(if % 1 0) bs)) 2))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$bool_seq__GT_long 0x6708524c \\\\\\\"advent_of_code_2021.day20$bool_seq__GT_long@6708524c\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Given the state of the image and a pixel returns the offset into the \\n algorithm to look for that pixel's next state--lit or not lit. Accounts for\\n the pixel's coordinates pointing into the expanse.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn offset-at\\n  [{:keys [img expanse] :as state} [x y]]\\n  (bool-seq->long\\n    (for [dy [-1 0 1]\\n          dx [-1 0 1]\\n          :let [p [(+ x dx) (+ y dy)]]]\\n      (if (expanse? state p)\\n        expanse\\n        (contains? img p)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$offset_at 0x5b04a049 \\\\\\\"advent_of_code_2021.day20$offset_at@5b04a049\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Given the state of the image returns the next state by applying the algorithm \\n for each pixel in the image and 1 pixel around the edge of the image. All\\n pixels in the expanse change in the same way except for those that border the\\n existing image. The expanse state transition is modeled in a different\\n function.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn next-img \\n  [{:keys [alg min-x max-x min-y max-y] :as state}]\\n  (assoc state\\n         :img\\n         (into #{}\\n               (filter #(contains? alg (offset-at state %)))\\n               (for [y (range (dec min-y) (+ max-y 2))\\n                     x (range (dec min-x) (+ max-x 2))]\\n                 [x y]))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$next_img 0x28f9e137 \\\\\\\"advent_of_code_2021.day20$next_img@28f9e137\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" If the expanse is all not lit then every pixel there should be `alg[0]` if\\n they are all lit (like after step 1 of my puzzle input) then the offset is\\n `0b111111111 = 511` so every pixel should be turned to `alg[511]`.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn next-expanse\\n  [{:keys [alg expanse] :as state}]\\n  (assoc state :expanse (contains? alg (if expanse 511 0))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$next_expanse 0x15b35d3a \\\\\\\"advent_of_code_2021.day20$next_expanse@15b35d3a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Expands the bounds of the img.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn expand-bounds\\n  [state]\\n  (-> state\\n      (update :min-x dec)\\n      (update :max-x inc)\\n      (update :min-y dec)\\n      (update :max-y inc)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$expand_bounds 0x300cf7f2 \\\\\\\"advent_of_code_2021.day20$expand_bounds@300cf7f2\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" A full step transitions all the parts of the state:\\n 1. `img` - the set of lit pixel coordinates\\n 2. `alg` - the algorithm, stays constant\\n 3. bounds - expands by 1 pixel in each direction \\n 4. `expanse` - if the pixels in the expanse are lit or not.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn step\\n  [state]\\n  (-> state next-img next-expanse expand-bounds))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$step 0x4e741f52 \\\\\\\"advent_of_code_2021.day20$step@4e741f52\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Enhance! n steps.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn enhance\\n  [input n]\\n  (->> (iterate step input)\\n       (drop n)\\n       (first)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$enhance 0x29e3bff2 \\\\\\\"advent_of_code_2021.day20$enhance@29e3bff2\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn solve-part1\\n  [input]\\n  (count (:img (enhance input 2))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$solve_part1 0x26366d79 \\\\\\\"advent_of_code_2021.day20$solve_part1@26366d79\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 35, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x2c7fb24c \\\\\\\"clojure.core$number_QMARK_@2c7fb24c\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5065, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x2c7fb24c \\\\\\\"clojure.core$number_QMARK_@2c7fb24c\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn solve-part2\\n  [input]\\n  (count (:img (enhance input 50))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day20$solve_part2 0x71d2ad2a \\\\\\\"advent_of_code_2021.day20$solve_part2@71d2ad2a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x64e6f678 \\\\\\\"clojure.core$fn_QMARK_@64e6f678\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 3351, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x2c7fb24c \\\\\\\"clojure.core$number_QMARK_@2c7fb24c\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 14790, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x2c7fb24c \\\\\\\"clojure.core$number_QMARK_@2c7fb24c\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" I didn't find the image that interesting.\\n\", :nextjournal/viewer :markdown}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :advent-of-code-2021.day20}}"
viewer.reset_doc(viewer.read_string(doc))
viewer.mount(document.getElementById('clerk'))
</script></body></html>