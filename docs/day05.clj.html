<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VujAQ3bHzgNYiC3C61DJwUmXP7xW6bB8tT92xAKhDyu5vXReakaHVSrqJfurggZdCJVuAf3B7AujNBvkJAcz974uH" type="text/javascript"></script></head><body><div id="clerk"></div><script>let viewer = nextjournal.clerk.sci_viewer
let doc = "{:nextjournal/value [{:nextjournal/value \"# [Day 05](https://adventofcode.com/2021/day/5) \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(ns advent-of-code-2021.day05\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as string]\\n            [nextjournal.clerk :as clerk]\\n            [nextjournal.clerk.viewer :as v]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"ojure.core$nil_QMARK_ 0x2f48adcc \\\\\\\"clojure.core$nil_QMARK_@2f48adcc\\\\\\\"\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" read the input into strings\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def real-input (slurp (io/resource \\\"day05.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"578,391 -> 578,322\\\\n274,585 -> 651,962\\\\n482,348 -> 294,348\\\\n682,514 -> 367,829\\\\n180,243 -> 800,863\\\\n850,8\\\" {:nextjournal/value {:path [], :count 9269, :offset 100, :remaining 9169}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input \\\"0,9 -> 5,9\\n8,0 -> 0,8\\n9,4 -> 3,4\\n2,2 -> 2,1\\n7,0 -> 7,4\\n6,4 -> 2,0\\n0,9 -> 2,9\\n3,4 -> 1,4\\n0,0 -> 8,8\\n5,5 -> 8,2\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"0,9 -> 5,9\\\\n8,0 -> 0,8\\\\n9,4 -> 3,4\\\\n2,2 -> 2,1\\\\n7,0 -> 7,4\\\\n6,4 -> 2,0\\\\n0,9 -> 2,9\\\\n3,4 -> 1,4\\\\n0,0 -> 8,8\\\\n5\\\" {:nextjournal/value {:path [], :count 109, :offset 100, :remaining 9}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn read-input\\n  [input]\\n  (map (fn [line]\\n         (let [[matches] (re-seq #\\\"(\\\\d+),(\\\\d+) \\\\-\\\\> (\\\\d+),(\\\\d+)\\\" line)\\n               [x0 y0 x1 y1] (map #(Long/valueOf %) (rest matches))]\\n           [[x0 y0] [x1 y1]]))\\n       (string/split-lines input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$read_input 0x41efbd29 \\\\\\\"advent_of_code_2021.day05$read_input@41efbd29\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Add 2 2d vectors.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn vec+\\n  [[x0 y0] [x1 y1]]\\n  [(+ x0 x1) (+ y0 y1)])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$vec_PLUS_ 0x42081e5f \\\\\\\"advent_of_code_2021.day05$vec_PLUS_@42081e5f\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" One way to draw a line is to get a unit vector between the two points. Start\\n at the first point and add the unit vector some number of times until you\\n arrive at the second point. That is what is done here except that the unit\\n vector isn't a true unit vector because it doesn't always have a length of 1.\\n Because of the constraint that the lines can only have slopes of 0, 1, -1, and\\n vertical (1/0 slope) the easiest way is to have potential unit vectors of\\n where each element can be 0, 1, or -1. It's more of a direction than a true\\n unit vector.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn unit\\n  [a b]\\n  (cond (< a b) 1\\n        (> a b) -1\\n        :else 0))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$unit 0x63c5b63a \\\\\\\"advent_of_code_2021.day05$unit@63c5b63a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn unit-vec \\n  [[x0 y0] [x1 y1]]\\n  ;\\n  [(unit x0 x1)\\n   (unit y0 y1)])\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$unit_vec 0x1ad66c9d \\\\\\\"advent_of_code_2021.day05$unit_vec@1ad66c9d\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn draw-line\\n  ([[start end]]\\n   (draw-line start end (unit-vec start end) []))\\n  ([start end diff points]\\n   (if (= start end)\\n     (conj points start)\\n     (recur (vec+ start diff)\\n            end\\n            diff\\n            (conj points start)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$draw_line 0x26ec9c1b \\\\\\\"advent_of_code_2021.day05$draw_line@26ec9c1b\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" To count overlapping just count how many of the same point there are and only\\n include those that appear more than once.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn count-overlapping\\n  [points]\\n  (->> points\\n       frequencies\\n       (filter #(<= 2 (val %)))\\n       count))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$count_overlapping 0x2494847f \\\\\\\"advent_of_code_2021.day05$count_overlapping@2494847f\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" In this implementation the solution to part1 turns out to be a special case\\n of part2 because they are the same except part1 requires extra filtering.\\n In both cases, the idea is to take the input lines and get the points between\\n them and put them all in the same collection and then count the frequency of\\n each.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn solve-part1\\n  [input]\\n  (count-overlapping\\n    (into []\\n          (comp (filter (fn [[[x0 y0] [x1 y1]]]\\n                          (or (= x0 x1)\\n                              (= y0 y1))))\\n                (mapcat draw-line))\\n          input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$solve_part1 0x6aae82b1 \\\\\\\"advent_of_code_2021.day05$solve_part1@6aae82b1\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 5084, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn solve-part2\\n  [input]\\n  (count-overlapping (mapcat draw-line input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day05$solve_part2 0x43b5a9fd \\\\\\\"advent_of_code_2021.day05$solve_part2@43b5a9fd\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input test-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 12, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 17882, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :advent-of-code-2021.day05}}"
viewer.reset_doc(viewer.read_string(doc))
viewer.mount(document.getElementById('clerk'))
</script></body></html>