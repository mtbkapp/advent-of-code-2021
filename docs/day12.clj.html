<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1" name="viewport"><link href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxQBDwk3cvr1bt8YVL5m6bJGrFEmzrSbCrH1roypLjJr4AbbteCKh9Y6gQVYexdY85QA2HG5nQFLWpRp69zFSPDJ9" rel="stylesheet" type="text/css"><link href="https://storage.googleapis.com/nextjournal-cas-eu/data/8VxoxUgsBRs2yjjBBcfeCc8XigM7erXHmjJg2tjdGxNBxwTYuDonuYswXqRStaCA2b3rTEPCgPwixJmAVrea1qAHHU" rel="stylesheet" type="text/css"><script src="https://storage.googleapis.com/nextjournal-cas-eu/data/8VujAQ3bHzgNYiC3C61DJwUmXP7xW6bB8tT92xAKhDyu5vXReakaHVSrqJfurggZdCJVuAf3B7AujNBvkJAcz974uH" type="text/javascript"></script></head><body><div id="clerk"></div><script>let viewer = nextjournal.clerk.sci_viewer
let doc = "{:nextjournal/value [{:nextjournal/value \"# [Day 12](https://adventofcode.com/2021/day/12)\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(ns advent-of-code-2021.day12\\n  (:require [clojure.java.io :as io]\\n            [clojure.string :as string]\\n            [nextjournal.clerk :as clerk]\\n            [nextjournal.clerk.viewer :as v]))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value nil, :nextjournal/viewer {:pred #function+ \\\"ojure.core$nil_QMARK_ 0x2f48adcc \\\\\\\"clojure.core$nil_QMARK_@2f48adcc\\\\\\\"\\\", :fn #function+ (fn [_] (v/html [:span.syntax-nil.inspected-value \\\"nil\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def real-input (slurp (io/resource \\\"day12.txt\\\")))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"vp-BY\\\\nui-oo\\\\nkk-IY\\\\nij-vp\\\\noo-start\\\\nSP-ij\\\\nkg-uj\\\\nij-UH\\\\nSP-end\\\\noo-IY\\\\nSP-kk\\\\nSP-vp\\\\nui-ij\\\\nUH-ui\\\\nij-IY\\\\nstart-\\\" {:nextjournal/value {:path [], :count 162, :offset 100, :remaining 62}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Works like `conj` except that in the case that the first arg is nil it will\\n replace it with `#{}`. So `(conj-set nil :A) => #{:A}` instead of `(:A)`. \\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(def conj-set (fnil conj #{}))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"ojure.core$fnil$fn__6915 0x70bf2681 \\\\\\\"clojure.core$fnil$fn__6915@70bf2681\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The graph is stored as a mapping from a room to a set of adjacent rooms. This \\n function updates the graph with a given undirected edge taking care that\\n `:start` is never in any room's adjacent set and `:end` only appears in\\n adjacent sets.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn add-edge\\n  [graph [a b]]\\n  (cond-> graph\\n    (and (not= :end b) (not= :start a)) (update b conj-set a)\\n    (and (not= :end a) (not= :start b)) (update a conj-set b)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$add_edge 0x304551d8 \\\\\\\"advent_of_code_2021.day12$add_edge@304551d8\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn read-input\\n  [input]\\n  (transduce\\n    (comp (map #(string/split % #\\\"-\\\"))\\n          (map #(mapv keyword %)))\\n    (completing add-edge)\\n    {}\\n    (string/split-lines input)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$read_input 0x115c112 \\\\\\\"advent_of_code_2021.day12$read_input@115c112\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Part 1\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn big?\\n  [room]\\n  (= (str room) (string/upper-case (str room))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$big_QMARK_ 0x3c4a710c \\\\\\\"advent_of_code_2021.day12$big_QMARK_@3c4a710c\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn small?\\n  [room]\\n  (or (= room :start)\\n      (= room :end)\\n      (not (big? room))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$small_QMARK_ 0x35c8d32a \\\\\\\"advent_of_code_2021.day12$small_QMARK_@35c8d32a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" The main part of the algorithm. This recursive function returns all the paths\\n to end given an input graph, the path traveled so far, and room currently\\n being visited.\\n * The base case is where `room` is the `:end` room so it just returns a single\\n   path with :end added to the end of the path traveled so far.\\n * The recursive case takes the rooms adjacent to the given room and removing\\n   small rooms which have already been visited. Each of these rooms is\\n   considered independently by making a recursive call with the path updated\\n   with the given room and the current room being each adjacent room. When\\n   the paths are returned from each recursive call they are combined and\\n   returned.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn paths-from\\n  [graph path-to room]\\n  (if (= :end room)\\n    [(conj path-to room)]\\n    (into []\\n          (comp (remove (into #{} (filter small?) path-to))\\n                (mapcat (partial paths-from graph (conj path-to room))))\\n          (get graph room))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$paths_from 0x2f198fda \\\\\\\"advent_of_code_2021.day12$paths_from@2f198fda\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn solve-part1\\n  [graph]\\n  (count (paths-from graph [] :start)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$solve_part1 0xabc67a \\\\\\\"advent_of_code_2021.day12$solve_part1@abc67a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input1\\n  \\\"start-A\\nstart-b\\nA-c\\nA-b\\nb-d\\nA-end\\nb-end\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"start-A\\\\nstart-b\\\\nA-c\\\\nA-b\\\\nb-d\\\\nA-end\\\\nb-end\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input1))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 10, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input2\\n  \\\"dc-end\\nHN-start\\nstart-kj\\ndc-start\\ndc-HN\\nLN-dc\\nHN-end\\nkj-sa\\nkj-HN\\nkj-dc\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"dc-end\\\\nHN-start\\\\nstart-kj\\\\ndc-start\\\\ndc-HN\\\\nLN-dc\\\\nHN-end\\\\nkj-sa\\\\nkj-HN\\\\nkj-dc\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input2))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 19, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(def test-input3\\n  \\\"fs-end\\nhe-DX\\nfs-he\\nstart-DX\\npj-DX\\nend-zg\\nzg-sl\\nzg-pj\\npj-he\\nRW-he\\nfs-DX\\npj-RW\\nzg-RW\\nstart-pj\\nhe-WI\\nzg-he\\npj-fs\\nstart-RW\\\")\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value [\\\"fs-end\\\\nhe-DX\\\\nfs-he\\\\nstart-DX\\\\npj-DX\\\\nend-zg\\\\nzg-sl\\\\nzg-pj\\\\npj-he\\\\nRW-he\\\\nfs-DX\\\\npj-RW\\\\nzg-RW\\\\nstart-pj\\\\nhe-WI\\\\nzg\\\" {:nextjournal/value {:path [], :count 118, :offset 100, :remaining 18}, :nextjournal/viewer :elision}], :replace-path [0], :nextjournal/viewer {:pred #function+ \\\"ojure.core$string_QMARK___5427 0x4d0402b \\\\\\\"clojure.core$string_QMARK___5427@4d0402b\\\\\\\"\\\", :fn #function+ v/string-viewer, :fetch-opts {:n 100}}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part1 (read-input test-input3))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 226, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" Ok, ok solve for the real graph and get a gold star!\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(solve-part1 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 4754, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \" ## Part 2 - now the sub can visit a single small room twice.\\n\", :nextjournal/viewer :markdown} {:nextjournal/value \"(defn visited-two-small? \\n  [path]\\n  (->> (frequencies path)\\n       (filter (fn [[room visit-count]]\\n                 (and (small? room)\\n                      (= 2 visit-count))))\\n       (count)\\n       (= 1)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$visited_two_small_QMARK_ 0x6f060572 \\\\\\\"advent_of_code_2021.day12$visited_two_small_QMARK_@6f060572\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn adjacent\\n  [graph path room]\\n  (let [adj (get graph room)]\\n    (if (visited-two-small? path)\\n      (remove (into #{} (filter small?) path) adj)\\n      adj)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$adjacent 0x1c24ca3b \\\\\\\"advent_of_code_2021.day12$adjacent@1c24ca3b\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn paths-from2\\n  [graph path-to room]\\n  (let [new-path (conj path-to room)]\\n    (if (= :end room)\\n      [new-path]\\n      (mapcat (fn [adj]\\n                (paths-from2 graph new-path adj))\\n              (adjacent graph new-path room)))))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$paths_from2 0x7fa0e13a \\\\\\\"advent_of_code_2021.day12$paths_from2@7fa0e13a\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(defn solve-part2\\n  [graph]\\n  (count (paths-from2 graph [] :start)))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value \\\"vent_of_code_2021.day12$solve_part2 0x21e660a2 \\\\\\\"advent_of_code_2021.day12$solve_part2@21e660a2\\\\\\\"\\\", :nextjournal/viewer {:pred #function+ \\\"ojure.core$fn_QMARK_ 0x2dacaa7f \\\\\\\"clojure.core$fn_QMARK_@2dacaa7f\\\\\\\"\\\", :name :fn, :fn #function+ (fn [x] (v/html [:span.inspected-value [:span.syntax-tag \\\"#function\\\"] \\\"[\\\" x \\\"]\\\"]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input test-input1))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 36, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result} {:nextjournal/value \"(solve-part2 (read-input real-input))\", :nextjournal/viewer :code} {:nextjournal/value {:edn \"{:path [], :nextjournal/value 143562, :nextjournal/viewer {:pred #function+ \\\"ojure.core$number_QMARK_ 0x43b9ef41 \\\\\\\"clojure.core$number_QMARK_@43b9ef41\\\\\\\"\\\", :fn #function+ (fn [x] (v/html [:span.syntax-number.inspected-value (if (js/Number.isNaN x) \\\"NaN\\\" (str x))]))}}\"}, :nextjournal/viewer :clerk/inline-result}], :nextjournal/viewer :clerk/notebook, :scope {:namespace :advent-of-code-2021.day12}}"
viewer.reset_doc(viewer.read_string(doc))
viewer.mount(document.getElementById('clerk'))
</script></body></html>